# 网络协议栈实验报告

## 实验概述

本实验实现了一个简化的网络协议栈，包括以太网层、ARP协议、IP协议、ICMP协议、UDP协议、TCP协议以及HTTP Web服务器。

---

## 一、校验和计算 (checksum16)

### 1.1 实现原理

`checksum16` 函数用于计算 16 位校验和，采用反码求和算法：

1. 将数据按 16 位（2字节）为单位累加
2. 如果数据长度为奇数，最后一个字节单独处理
3. 将累加结果中超过 16 位的高位折叠到低 16 位
4. 返回结果的反码

### 1.2 代码实现

```c
uint16_t checksum16(uint16_t *data, size_t len) {
    uint32_t sum = 0;
    size_t i;

    // Step1: 按16位累加数据（大端序读取）
    for (i = 0; i + 1 < len; i += 2) {
        uint16_t word = ((uint8_t *)data)[i] << 8 | ((uint8_t *)data)[i + 1];
        sum += word;
    }

    // Step2: 处理奇数长度
    if (len & 1) {
        sum += ((uint8_t *)data)[len - 1] << 8;
    }

    // Step3: 高16位折叠到低16位
    while (sum >> 16) {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }

    // Step4: 返回反码
    return (uint16_t)(~sum);
}
```

---

## 二、IP协议实现

### 2.1 ip_in() - IP数据包接收

**功能**：处理接收到的IP数据包，验证并分发到上层协议。

**实现步骤**：
1. 检查数据包长度是否足够
2. 验证IP版本号为4
3. 验证首部长度 ≥ 5
4. 验证总长度字段
5. 验证首部校验和
6. 检查目的IP地址
7. 去除填充字段
8. 调用 `net_in()` 分发到上层

```c
void ip_in(buf_t *buf, uint8_t *src_mac) {
    // 检查长度
    if (buf->len < sizeof(ip_hdr_t)) return;
    
    ip_hdr_t *hdr = (ip_hdr_t *)buf->data;
    
    // 验证版本号和首部长度
    if (hdr->version != IP_VERSION_4) return;
    if (hdr->hdr_len < 5) return;
    
    // 验证总长度
    uint16_t total_len = swap16(hdr->total_len16);
    if (total_len > buf->len) return;
    
    // 验证校验和
    uint16_t recv_checksum = hdr->hdr_checksum16;
    hdr->hdr_checksum16 = 0;
    uint16_t calc_checksum = swap16(checksum16((uint16_t *)hdr, hdr->hdr_len * 4));
    if (recv_checksum != calc_checksum) return;
    hdr->hdr_checksum16 = recv_checksum;
    
    // 检查目的IP
    if (memcmp(hdr->dst_ip, net_if_ip, NET_IP_LEN) != 0) return;
    
    // 去除填充
    if (buf->len > total_len) {
        buf_remove_padding(buf, buf->len - total_len);
    }
    
    // 去除IP首部，分发到上层
    buf_remove_header(buf, hdr->hdr_len * 4);
    net_in(buf, hdr->protocol, hdr->src_ip);
}
```

### 2.2 ip_fragment_out() - IP分片发送

**功能**：添加IP首部并发送单个IP分片。

```c
void ip_fragment_out(buf_t *buf, uint8_t *ip, net_protocol_t protocol, 
                     int id, uint16_t offset, int mf) {
    buf_add_header(buf, sizeof(ip_hdr_t));
    ip_hdr_t *hdr = (ip_hdr_t *)buf->data;
    
    hdr->version = IP_VERSION_4;
    hdr->hdr_len = 5;
    hdr->tos = 0;
    hdr->total_len16 = swap16(buf->len);
    hdr->id16 = swap16(id);
    hdr->flags_fragment16 = swap16((mf ? IP_MORE_FRAGMENT : 0) | offset);
    hdr->ttl = IP_DEFALUT_TTL;
    hdr->protocol = protocol;
    memcpy(hdr->src_ip, net_if_ip, NET_IP_LEN);
    memcpy(hdr->dst_ip, ip, NET_IP_LEN);
    
    hdr->hdr_checksum16 = 0;
    hdr->hdr_checksum16 = swap16(checksum16((uint16_t *)hdr, sizeof(ip_hdr_t)));
    
    arp_out(buf, ip);
}
```

### 2.3 ip_out() - IP数据包发送

**功能**：处理IP分片（如需要）并发送数据包。

```c
void ip_out(buf_t *buf, uint8_t *ip, net_protocol_t protocol) {
    static int packet_id = 0;
    size_t max_payload = ETHERNET_MAX_TRANSPORT_UNIT - sizeof(ip_hdr_t);
    
    if (buf->len <= max_payload) {
        ip_fragment_out(buf, ip, protocol, packet_id++, 0, 0);
    } else {
        size_t offset = 0;
        while (buf->len > 0) {
            size_t frag_len = (buf->len > max_payload) ? (max_payload & ~7) : buf->len;
            buf_t frag_buf;
            buf_init(&frag_buf, frag_len);
            memcpy(frag_buf.data, buf->data, frag_len);
            
            int mf = (buf->len > frag_len) ? 1 : 0;
            ip_fragment_out(&frag_buf, ip, protocol, packet_id, offset / 8, mf);
            
            buf_remove_header(buf, frag_len);
            offset += frag_len;
        }
        packet_id++;
    }
}
```

---

## 三、ICMP协议实现

### 3.1 icmp_in() - ICMP数据包接收

```c
void icmp_in(buf_t *buf, uint8_t *src_ip) {
    if (buf->len < sizeof(icmp_hdr_t)) return;
    
    icmp_hdr_t *hdr = (icmp_hdr_t *)buf->data;
    if (hdr->type == ICMP_TYPE_ECHO_REQUEST) {
        icmp_resp(buf, src_ip);
    }
}
```

### 3.2 icmp_resp() - ICMP回显应答

```c
void icmp_resp(buf_t *buf, uint8_t *src_ip) {
    buf_init(&txbuf, buf->len);
    memcpy(txbuf.data, buf->data, buf->len);
    
    icmp_hdr_t *hdr = (icmp_hdr_t *)txbuf.data;
    hdr->type = ICMP_TYPE_ECHO_REPLY;
    hdr->code = 0;
    hdr->checksum16 = 0;
    hdr->checksum16 = swap16(checksum16((uint16_t *)txbuf.data, txbuf.len));
    
    ip_out(&txbuf, src_ip, NET_PROTOCOL_ICMP);
}
```

### 3.3 icmp_unreachable() - ICMP不可达报文

```c
void icmp_unreachable(buf_t *recv_buf, uint8_t *src_ip, icmp_code_t code) {
    ip_hdr_t *recv_ip_hdr = (ip_hdr_t *)recv_buf->data;
    size_t ip_hdr_len = recv_ip_hdr->hdr_len * 4;
    size_t copy_len = ip_hdr_len + 8;
    
    buf_init(&txbuf, sizeof(icmp_hdr_t) + copy_len);
    memcpy(txbuf.data + sizeof(icmp_hdr_t), recv_buf->data, copy_len);
    
    icmp_hdr_t *hdr = (icmp_hdr_t *)txbuf.data;
    hdr->type = ICMP_TYPE_UNREACH;
    hdr->code = code;
    hdr->id16 = 0;
    hdr->seq16 = 0;
    hdr->checksum16 = 0;
    hdr->checksum16 = swap16(checksum16((uint16_t *)txbuf.data, txbuf.len));
    
    ip_out(&txbuf, src_ip, NET_PROTOCOL_ICMP);
}
```

---

## 四、UDP协议实现

### 4.1 transport_checksum() - 传输层校验和

```c
uint16_t transport_checksum(buf_t *buf, uint8_t *src_ip, uint8_t *dst_ip, 
                            net_protocol_t protocol) {
    // 保存原始数据
    uint8_t saved_data[sizeof(peso_hdr_t)];
    memcpy(saved_data, buf->data - sizeof(peso_hdr_t), sizeof(peso_hdr_t));
    
    // 添加伪首部
    buf_add_header(buf, sizeof(peso_hdr_t));
    peso_hdr_t *peso = (peso_hdr_t *)buf->data;
    memcpy(peso->src_ip, src_ip, NET_IP_LEN);
    memcpy(peso->dst_ip, dst_ip, NET_IP_LEN);
    peso->placeholder = 0;
    peso->protocol = protocol;
    peso->total_len16 = swap16(buf->len - sizeof(peso_hdr_t));
    
    // 计算校验和
    uint16_t checksum = checksum16((uint16_t *)buf->data, buf->len);
    
    // 恢复原始数据
    memcpy(buf->data, saved_data, sizeof(peso_hdr_t));
    buf_remove_header(buf, sizeof(peso_hdr_t));
    
    return swap16(checksum);
}
```

### 4.2 udp_in() - UDP数据包接收

```c
void udp_in(buf_t *buf, uint8_t *src_ip) {
    if (buf->len < sizeof(udp_hdr_t)) return;
    
    udp_hdr_t *hdr = (udp_hdr_t *)buf->data;
    uint16_t total_len = swap16(hdr->total_len16);
    if (total_len > buf->len) return;
    
    // 验证校验和
    uint16_t recv_checksum = hdr->checksum16;
    hdr->checksum16 = 0;
    uint16_t calc_checksum = transport_checksum(buf, src_ip, net_if_ip, NET_PROTOCOL_UDP);
    if (recv_checksum != calc_checksum) return;
    
    uint16_t dst_port = swap16(hdr->dst_port16);
    udp_handler_t *handler = map_get(&udp_table, &dst_port);
    
    if (handler == NULL) {
        buf_add_header(buf, sizeof(ip_hdr_t));
        icmp_unreachable(buf, src_ip, ICMP_CODE_PORT_UNREACH);
    } else {
        buf_remove_header(buf, sizeof(udp_hdr_t));
        (*handler)(buf->data, buf->len, src_ip, swap16(hdr->src_port16));
    }
}
```

### 4.3 udp_out() - UDP数据包发送

```c
void udp_out(uint8_t *data, uint16_t len, uint16_t src_port, 
             uint8_t *dest_ip, uint16_t dest_port) {
    buf_init(&txbuf, len);
    memcpy(txbuf.data, data, len);
    
    buf_add_header(&txbuf, sizeof(udp_hdr_t));
    udp_hdr_t *hdr = (udp_hdr_t *)txbuf.data;
    
    hdr->src_port16 = swap16(src_port);
    hdr->dst_port16 = swap16(dest_port);
    hdr->total_len16 = swap16(txbuf.len);
    hdr->checksum16 = 0;
    hdr->checksum16 = transport_checksum(&txbuf, net_if_ip, dest_ip, NET_PROTOCOL_UDP);
    
    ip_out(&txbuf, dest_ip, NET_PROTOCOL_UDP);
}
```

---

## 五、TCP协议实现

### 5.1 tcp_out() - TCP数据包发送

```c
void tcp_out(tcp_conn_t *tcp_conn, buf_t *buf, uint16_t src_port, 
             uint8_t *dst_ip, uint16_t dst_port, tcp_flags_t flags) {
    buf_add_header(buf, sizeof(tcp_hdr_t));
    tcp_hdr_t *hdr = (tcp_hdr_t *)buf->data;
    
    hdr->src_port16 = swap16(src_port);
    hdr->dst_port16 = swap16(dst_port);
    hdr->seq_number32 = swap32(tcp_conn->seq);
    hdr->ack_number32 = swap32(tcp_conn->ack);
    hdr->data_offset = 5;
    hdr->reserved = 0;
    hdr->flags = flags;
    hdr->window_size16 = swap16(tcp_conn->window_size);
    hdr->urgent_pointer16 = 0;
    
    hdr->checksum16 = 0;
    hdr->checksum16 = transport_checksum(buf, net_if_ip, dst_ip, NET_PROTOCOL_TCP);
    
    ip_out(buf, dst_ip, NET_PROTOCOL_TCP);
}
```

### 5.2 tcp_in() - TCP状态机处理

```c
void tcp_in(buf_t *buf, uint8_t *src_ip) {
    // ... 包验证代码省略 ...
    
    switch (tcp_conn->state) {
        case TCP_STATE_LISTEN:
            if (!TCP_FLG_ISSET(recv_flags, TCP_FLG_SYN)) return;
            tcp_conn->seq = tcp_generate_initial_seq();
            tcp_conn->ack = remote_seq + 1;
            send_flags = TCP_FLG_SYN | TCP_FLG_ACK;
            tcp_conn->state = TCP_STATE_SYN_RECEIVED;
            break;

        case TCP_STATE_SYN_RECEIVED:
            if (!TCP_FLG_ISSET(recv_flags, TCP_FLG_ACK)) return;
            tcp_conn->state = TCP_STATE_ESTABLISHED;
            break;

        case TCP_STATE_ESTABLISHED:
            if (remote_seq != tcp_conn->ack) {
                // 发送重复ACK
                buf_init(&txbuf, 0);
                tcp_out(tcp_conn, &txbuf, host_port, remote_ip, remote_port, TCP_FLG_ACK);
                return;
            }
            size_t data_len = buf->len - tcp_hdr_sz;
            tcp_conn->ack = remote_seq + bytes_in_flight(data_len, recv_flags);
            
            if (data_len > 0) send_flags |= TCP_FLG_ACK;
            if (TCP_FLG_ISSET(recv_flags, TCP_FLG_FIN)) {
                send_flags |= TCP_FLG_ACK | TCP_FLG_FIN;
                tcp_conn->state = TCP_STATE_LAST_ACK;
            }
            break;

        case TCP_STATE_LAST_ACK:
            if (!TCP_FLG_ISSET(recv_flags, TCP_FLG_ACK)) return;
            tcp_close_connection(remote_ip, remote_port, host_port);
            return;
    }
    
    // 数据交付给上层应用
    if (buf->len > tcp_hdr_sz) {
        tcp_handler_t *handler = map_get(&tcp_handler_table, &host_port);
        if (handler) {
            buf_remove_header(buf, tcp_hdr_sz);
            (*handler)(tcp_conn, buf->data, buf->len, remote_ip, remote_port);
        }
    }
    
    // 发送回复
    if (send_flags != 0) {
        buf_init(&txbuf, 0);
        tcp_out(tcp_conn, &txbuf, host_port, remote_ip, remote_port, send_flags);
        tcp_conn->seq += bytes_in_flight(0, send_flags);
    }
}
```

---

## 六、HTTP Web服务器实现

### 6.1 http_respond() - HTTP响应

```c
void http_respond(tcp_conn_t *tcp_conn, char *url_path, uint16_t port, 
                  uint8_t *dst_ip, uint16_t dst_port) {
    FILE *file;
    char file_path[HTTP_MAX_PATH_LENGTH];
    char resp_buffer[HTTP_MAX_RESPONSE_LENGTH] = {0};
    
    // 构建文件路径
    memcpy(file_path, HTTP_RESOURCE_DIR, sizeof(HTTP_RESOURCE_DIR));
    if (strcmp(url_path, "/") == 0) {
        strcat(file_path, "/index.html");
    } else {
        strcat(file_path, url_path);
    }
    
    file = fopen(file_path, "rb");
    
    if (!file) {
        // 404 响应
        char *not_found_body = "<HTML><TITLE>Not Found</TITLE>\r\n"
                               "The resource specified\r\n"
                               "is unavailable or nonexistent.\r\n"
                               "</BODY></HTML>\r\n";
        
        sprintf(resp_buffer, "HTTP/1.1 404 Not Found\r\n");
        tcp_send(tcp_conn, (uint8_t *)resp_buffer, strlen(resp_buffer), port, dst_ip, dst_port);
        
        sprintf(resp_buffer, "Connection: Keep-Alive\r\n");
        tcp_send(tcp_conn, (uint8_t *)resp_buffer, strlen(resp_buffer), port, dst_ip, dst_port);
        
        sprintf(resp_buffer, "Content-Type: text/html; charset=utf-8\r\n");
        tcp_send(tcp_conn, (uint8_t *)resp_buffer, strlen(resp_buffer), port, dst_ip, dst_port);
        
        sprintf(resp_buffer, "Content-Length: %zu\r\n", strlen(not_found_body));
        tcp_send(tcp_conn, (uint8_t *)resp_buffer, strlen(resp_buffer), port, dst_ip, dst_port);
        
        sprintf(resp_buffer, "\r\n");
        tcp_send(tcp_conn, (uint8_t *)resp_buffer, strlen(resp_buffer), port, dst_ip, dst_port);
        
        tcp_send(tcp_conn, (uint8_t *)not_found_body, strlen(not_found_body), port, dst_ip, dst_port);
        return;
    }
    
    // 200 响应
    sprintf(resp_buffer, "HTTP/1.1 200 OK\r\n");
    tcp_send(tcp_conn, (uint8_t *)resp_buffer, strlen(resp_buffer), port, dst_ip, dst_port);
    
    sprintf(resp_buffer, "Connection: Keep-Alive\r\n");
    tcp_send(tcp_conn, (uint8_t *)resp_buffer, strlen(resp_buffer), port, dst_ip, dst_port);
    
    const char *content_type = http_get_mime_type(file_path);
    sprintf(resp_buffer, "Content-Type: %s\r\n", content_type);
    tcp_send(tcp_conn, (uint8_t *)resp_buffer, strlen(resp_buffer), port, dst_ip, dst_port);
    
    fseek(file, 0, SEEK_END);
    size_t content_length = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    sprintf(resp_buffer, "Content-Length: %zu\r\n", content_length);
    tcp_send(tcp_conn, (uint8_t *)resp_buffer, strlen(resp_buffer), port, dst_ip, dst_port);
    
    sprintf(resp_buffer, "\r\n");
    tcp_send(tcp_conn, (uint8_t *)resp_buffer, strlen(resp_buffer), port, dst_ip, dst_port);
    
    // 发送文件内容
    size_t bytes_read;
    while ((bytes_read = fread(resp_buffer, 1, sizeof(resp_buffer), file)) > 0) {
        tcp_send(tcp_conn, (uint8_t *)resp_buffer, bytes_read, port, dst_ip, dst_port);
    }
    
    fclose(file);
}
```

---

## 七、网络配置

### 7.1 config.h 配置文件

```c
#ifndef CONFIG_H
#define CONFIG_H

#ifdef TEST
#define NET_IF_IP          \
    {                      \
        192, 168, 163, 103 \
    }  // 测试用网卡ip地址
#define NET_IF_MAC                         \
    {                                      \
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66 \
    }  // 测试用网卡mac地址
#else
#define NET_IF_IP        \
    {                    \
        192, 168, 37, 123 \
    }  // 自定义网卡ip地址（使用VMware VMnet1网段）
#define NET_IF_MAC                         \
    {                                      \
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55 \
    }  // 自定义网卡mac地址
#endif

#define ETHERNET_MAX_TRANSPORT_UNIT 1500  // 以太网最大传输单元
#define ARP_TIMEOUT_SEC (60 * 5)          // arp表过期时间
#define ARP_MIN_INTERVAL 1                // 向相同地址发送arp请求的最小间隔
#define IP_DEFALUT_TTL 64                 // IP默认TTL
#define BUF_MAX_LEN (2 * UINT16_MAX + UINT8_MAX)  // buf最大长度
#define MAP_MAX_LEN (16 * BUF_MAX_LEN)    // map最大长度

#endif
```

### 7.2 网络配置要点

进行 TCP/UDP 服务器测试前，需确保：

1. **查看物理机IP地址**：运行 `ipconfig` 查看当前活动网卡的IP
2. **配置自定义网卡IP**：与物理机网卡同一网段，但主机号不同
3. **选择合适的网卡**：
   - Wi-Fi无线网卡不支持原始数据包发送
   - 推荐使用有线以太网或VMware虚拟网卡
4. **管理员权限**：Npcap发送数据包需要管理员权限运行

---

## 八、实验测试

### 8.1 单元测试

```powershell
cd C:\Users\Dau\Desktop\TempLearn\net-lab-main\net-lab\build
ctest -R eth_in     # 以太网接收测试
ctest -R eth_out    # 以太网发送测试
ctest -R arp_test   # ARP测试
ctest -R ip_test    # IP测试
ctest -R ip_frag_test  # IP分片测试
ctest -R icmp_test  # ICMP测试
ctest -R udp_test   # UDP测试
ctest -R tcp_test   # TCP测试
```

### 8.2 服务器测试

```powershell
# 以管理员权限运行
.\tcp_server.exe    # TCP服务器
.\udp_server.exe    # UDP服务器
.\web_server.exe    # Web服务器
```

---

## 九、实验总结

### 9.1 关键技术点

1. **字节序转换**：网络字节序（大端）与主机字节序（小端）转换使用 `swap16()` 和 `swap32()`
2. **校验和计算**：`checksum16()` 返回主机序，赋值给结构体字段时需要 `swap16()` 转换
3. **传输层校验和**：需要添加12字节伪首部
4. **TCP状态机**：LISTEN → SYN_RECEIVED → ESTABLISHED → LAST_ACK

### 9.2 遇到的问题及解决

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 校验和字节序错误 | checksum16返回主机序 | 使用swap16()包装 |
| 网卡发送失败 | Wi-Fi不支持原始包发送 | 使用VMware虚拟网卡 |
| 权限不足 | Npcap需要管理员权限 | 以管理员身份运行 |

### 9.3 实验收获

- 深入理解了网络协议栈的分层架构
- 掌握了IP分片、TCP状态机等核心机制
- 熟悉了校验和计算、字节序转换等底层细节
- 实践了从协议解析到应用服务的完整流程

---

*实验完成日期：2025年12月2日*
